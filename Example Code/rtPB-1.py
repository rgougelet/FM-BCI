from framework.latentmodule import LatentModuleimport pylsl.pylsl as pylslimport scipy as spimport numpy as npimport pylab as pylimport matplotlib.pyplot as pltfrom scipy import signal as sigimport randomimport datetimeimport osimport sysimport time as tmimport picklefrom numpy import NaN, Inf, arange, isscalar, asarray, arrayimport Dependencies.Quest as Quest""" This script runs the real-time peak/trough presentation experiment.	Real-time threshold peak-detection script	Version: rtPB-1	Notes	tm.time() - returns time as floating point expressed in seconds since the epoch in UTC	offline trial data output - [trialType, trialNum, displayed, side, luminance, saw, rt]	online trial data output -  [trialtype, trialNum, displayed, side, luminance, saw, rt, detType]	TrialType: [0: Train, 1: Threshold, 2: Offline, 3: Filt Online, 4: Thresh Online, 5: Sham Online]"""class Main(LatentModule):	def __init__(self):		LatentModule.__init__(self)		## Set run version		self.runversion = 'rtPB-1'		## Set markers up		self.implicit_markers = False		self.extensive_markers = False		## Sets background colour to gray		base.win.setClearColor((0.5, 0.5, 0.5, 1))		## Set up variables for EEG		self.filter = False		self.eegsystem = 'BrainProducts'		if self.eegsystem == 'BrainProducts':			self.chans = [30, 14]			# chans[0] - chan to use; chans[1] - chan to re-ref to			self.srate = 5000.			self.nyq = self.srate/2.0			self.nsamples = 5000. 			# Number of samples to collect for filt trial		elif self.eegsystem == 'Biosemi':			self.chans = [30, 49]			# chans[0] - chan to use; chans[1] - chan to re-ref to			self.srate = 2048.			self.nyq = self.srate/2.0			self.nsamples = 2048. 			# Number of samples to collect for filt trial		## Set up variables for presentation		# Number of trials per block		self.ntrialperblock = 48		# Has to be divisible by 2 and 3 	- standard: 48		self.nthreshtrials = 144		# Has to be divisible by 2 			- standard: 144		self.blocknumber = 1 		# Initialize block number to one		self.nblocks = 10 			# Number of blocks to run in experiment		# Flash duration		self.flashtime = 0.030 		# Flash duration, in seconds		# Size of the fixation cross		self.fixationsize = 0.10		# Set positions for rectangles		self.lefttoppos = (-0.91,-0.89, 0.25, 0.125)		self.leftbotpos = (-0.91,-0.89, -0.25, -0.125)		self.righttoppos = (0.91, 0.89, 0.25, 0.125)		self.rightbotpos = (0.91, 0.89, -0.25, -0.125)		# Flash position		self.leftmidpos = (-0.904,-0.896, 0.004, -0.004)		self.rightmidpos = (0.904, 0.896, 0.004, -0.004)				## Check lsl versions		self.lslprotocolversion = pylsl.protocol_version()		self.lsllibraryversion = pylsl.library_version()		return	def run(self):		""" Master function - runs the program.		Program Logic:		- Sets things up (creates filter (with function), finds EEG, prepares study (sets up variables))		- Calls a function to take resting EEG and find alpha frequency		- Runs a training block for the task		- Runs a thresholding block to threshold behaviour		- Can run offline trial block and/or a labelling block of rest EEG		- Runs the online experiment, with presentation matched to peak or trough detection		"""		# Pause before starting		self.sleep(1)		## Set online or offline run		self.online = True		## Clear SNAP setup text		for clearline in range(1,25):			print('\n')		## Get Subject number & Condition		self.subnum = int(input('Subject Number: '))		# Condition: 1 is rtPB-1, as described in the outline		self.condition = int(input('Condition: '))		print "Running subject # ", str(self.subnum), "in condition # ", str(self.condition)		## Start		self.sleep(1)		print 'Starting setup. \n'		## Initialize file saving for trial data		self.datetimenow = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")		self.datafn = '.\\modules\\CBCI\\CSV\\' + str(self.subnum) + '_' + self.datetimenow + '_phaseRT.csv'		self.dataf = open(self.datafn,'w')		self.dataf.write('Trial Type, Trial Number, Disp, Side, Luminance, Saw, RT, Detection Type'+'\n')		self.dataf.close()		## Set up online stuff		if self.online:			## Probe EEG stream			print("Looking for EEG stream...")			EEG = pylsl.resolve_stream('type','EEG')			if not EEG:				print "No EEG stream resolved, operating without it\n"			else:				## Initialize EEG stream				print "EEG stream resolved\n"				EEGinlet = pylsl.stream_inlet(EEG[0], 1)				EEGinlet.open_stream()						## Check stream			checkstream = True			if checkstream:				self.checkstream(EEGinlet)			# Write the experiment log			self.experimentlog()		## Initialize Markers		self.marker("Initialize")		## Wait for experimenter to start experiment		print "Press space to begin \n"		self.waitfor('space')		print "Starting"		## Do initial online parts (get alpha freq, make filter, run labelling)		if self.online:			## Get individual alpha frequency			self.alpha = self.psdcheck(EEGinlet)			#self.alpha = 10.0			## Set up the filters			self.filter = self.filters()			## Non-task eeg labelling			# Randomly decide which prediction type comes first			nLabelBlocks = 1			if (round(random.random()) == 0.0):				for k in range(0, nLabelBlocks):					self.runlabelblock(EEGinlet, 'filt')					self.runlabelblock(EEGinlet, 'thresh')			else:				for k in range(0, nLabelBlocks):					self.runlabelblock(EEGinlet, 'thresh')					self.runlabelblock(EEGinlet, 'filt')		## Run offline parts - training, threshold, and offline trials		# Train subject on task		traindata = self.train(EEGinlet)		# Run Thresholding		#threshdata, lums = self.threshold_staircase()			# Old staircasing method		threshdata, lums = self.threshold_quest(EEGinlet) 		# New Quest adaptive method		# Run offline experiment (offline block)		# offlinedata1 = self.runofflineblock(EEGinlet, lums)		## Run real time experiment (online block)		#if self.online:		#	nOnline = 4 	# Number of each type to run		#	if (round(random.random()) == 0.0):		#		for j in range(0, nOnline):		#			onlineblock = self.runonlineblock(EEGinlet, 'filt', lums)		#			if j == 0:		#				onlinedata = onlineblock		#			else:		#				onlinedata = np.vstack([onlinedata, onlineblock])		#			onlineblock = self.runonlineblock(EEGinlet, 'thresh', lums)		#			onlinedata = np.vstack([onlinedata, onlineblock])		#	else:		#		for j in range(0, nOnline):		#			onlineblock = self.runonlineblock(EEGinlet, 'thresh', lums)		#			if j == 0:		#				onlinedata = onlineblock		#			else:		#				onlinedata = np.vstack([onlinedata, onlineblock])		#			onlineblock = self.runonlineblock(EEGinlet, 'filt', lums)		#			onlinedata = np.vstack([onlinedata, onlineblock])		# Run offline experiment (offline block)		#offlinedata2 = self.runofflineblock(EEGinlet, lums)		if self.online:			for k in range(0, self.nblocks):				datablock = self.runblock(EEGinlet, lums)				if k == 0:					data = datablock				else:					data = np.vstack([data, datablock])		## Save data to a npz file		if self.online:			savepath = '.\\modules\\CBCI\\Data\\'			savename = savepath + str(self.subnum) + '_' + self.datetimenow			#np.savez(savename, subnum=self.subnum, condition=self.condition, alpha=self.alpha, filter=self.bp, traindata=traindata, threshdata=threshdata, offlinedata1=offlinedata1, offlinedata2=offlinedata2, onlinedata=onlinedata)			np.savez(savename, subnum=self.subnum, condition=self.condition, alpha=self.alpha, filter=self.bp, traindata=traindata, threshdata=threshdata, data=data)		# End text		print "Data saved \n Experiment Finished"		self.write('You have successfully completed the experiment!')	def filters(self):		""" This function creates the filter that is used in the experiment.		Saves the filter in self.bp		Inputs:			self		Outputs:			Returns True if function ran properly		"""		## Generate Parks-McClelland FIR filter coefficients		self.center = self.alpha		self.lowcut = self.center-3		self.highcut = self.center+3		self.numtaps = int(self.srate/2)		self.nyq = 0.5 * self.srate 		#nyquist frequency		self.bp = sig.remez(self.numtaps,[0, self.lowcut, self.center, self.center, self.highcut, self.nyq],[0, 1, 0], Hz=self.srate, type='bandpass') # FIR		## Print filter details		print 'Filter created \n'		print '# of coeffs:', len(self.bp)		print 'Filter order:', self.numtaps, '\n'		## Set things for figures		#self.delaysamples = 0.5*(len(self.bp) - 1.) # in samples		#self.delaysecs = 0.5*(len(self.bp) - 1.)/self.srate		#self.padlength = round(self.delaysamples)		#self.EEGtimes = np.linspace(0.0,float(self.nsamples+self.padlength)/self.srate, num=self.nsamples+self.padlength)*1000.0		self.EEGsectimes = np.linspace(0.0,float(self.nsamples)/self.srate, num=self.nsamples)		## Check frequency response (plot)		# w,h = sig.freqz(self.bp,1)		# plt.figure		# plt.plot(w*self.nyq/np.pi, 20*np.log10(abs(h)))		# plt.show()			# Return True if filters initialized		return True	def psdcheck(self, EEGinlet):		""" Takes in 30 seconds of EEG data to return individualized alpha frequency. 		Inputs:			EEGinlet 	-lsl inlet for the EEG stream		Outputs:			alpha 		-frequency of the participants alpha		"""		# Initialize		EEGsample = pylsl.vectorf()		lengthrest = 30.0		nsamplesRest = int(self.srate * lengthrest)		EEGwindowRest = np.zeros(nsamplesRest)		# Print to screen 'Please close your eyes'		self.write('We will start with a check of the EEG data', 4)		self.write('This means you will have to close your eyes \n and hold still, for about 30 seconds.', 4)		self.write('Press space when you are ready, \n and then close your eyes.', 'space')		# Pause, then start collection		self.sleep(4)		print 'Starting rest EEG Collection'		# Take time to check how long collection is		timebeforerest = tm.time()		## Pull data for 30 seconds		# Clear buffer		while EEGinlet.pull_sample(EEGsample,0.0): # Clear buffer			pass		## Collect data		#for sampleIndex in np.arange(0, nsamplesRest):		for sampleIndex in range(0, nsamplesRest):			EEGinlet.pull_sample(EEGsample)			# Re-referenced data			EEGwindowRest[sampleIndex] = EEGsample[self.chans[0]] - EEGsample[self.chans[1]]	#Reref			# Non-rereferenced data			#EEGwindowRest[sampleIndex] = EEGsample[self.chans[0]]		# Get time after, and check how long colleciton is		timeafterrest = tm.time()		restcollecitontime = round(timeafterrest - timebeforerest)		print "Rest colleciton time: ", restcollecitontime		# Remove DC offset		EEGwindowRest = EEGwindowRest - np.mean(EEGwindowRest)		## Take psd, plot and ask experimenter to check		#f,psd = sp.signal.welch(EEGwindowRest, fs=self.srate, window='hanning', nperseg=1024., nfft=2048, detrend='linear', return_onesided=True, scaling='density')		f,psd = sp.signal.welch(EEGwindowRest, fs=self.srate, window='hanning', nperseg=2*self.srate, noverlap=self.srate/2, nfft=None, detrend='linear', return_onesided=True, scaling='density')		# Set psd range for visualization		fwin = [1, 50]		fwin = [np.argmin(abs(f-fwin[0])), np.argmin(abs(f-fwin[1]))]	#Find indices of f values closest to range of interest		f = f[fwin[0]:fwin[1]]		psd = psd[fwin[0]:fwin[1]]		# Plot psd		plt.figure(1)		plt.plot(f, np.log10(psd))		plt.show()		## Experimenter enters in peak alpha frequency		alpha = input('Peak Alpha Frequency: ')		alpha = float(alpha)		# Return alpha value		return alpha	def train(self, EEGinlet):		""" This function trains the participant on the task. 		Inputs:			EEGinlet	- lsl stream to pull data from		Outputs:			trainData  - a matrix of results for all training trials.						Collected from from runtrialoffline						[trialNum, displayed, side, lumUsed, saw, rt]		"""		## Set things up		trainlums1 = [1, 1]		trainlums2 = [[0.9, 0.9], [0.8,0.8], [0.7,0.7], [0.6,0.6], [0.5,0.5]]		## Explains the task		self.write('During this task you must keep you eyes focused on \n the cross at the middle of the screen.', 'space')		self.write('At the start of a trial, rectangles will appear \n on either the left or right side of the screen.', 'space')		self.write('Without moving your eyes, your job is to attend \n to the region between the rectangles. \n If you see a flash of light, press Space.', 'space')		## Run test trials		# Run a left side trial		self.write('Lets try a test trial, on the left side. \n Press Space when you are ready.', 'space')		self.sleep(1)		self.cross = self.crosshair(duration=0.0, block=False, color = (0,0,0,1), size=self.fixationsize)		self.sleep(1)		#trainTrialLeft = self.runtrialoffline(0, 0, 0, trainlums)							# Old offline version		trainTrialLeft = self.runtrialonline(0, EEGinlet, 0, 0, trainlums1)				# New sham online version		# Turn off fixation cross between trials		self.cross.destroy()		# Run a right side trial		self.write('Lets try a test trial, on the right side. \n Press Space when you are ready.', 'space')		self.sleep(1)		self.cross = self.crosshair(duration=0.0, block=False, color = (0,0,0,1), size=self.fixationsize)		self.sleep(1)		#trainTrialRight = self.runtrialoffline(0, 0, 1, trainlums)					# Old offline version		trainTrialRight = self.runtrialonline(0, EEGinlet, 0, 1, trainlums1)	# New sham online version		# Turn off fixation cross between trials		self.cross.destroy() 		## Run a few more trials - easy trials		nPractice1 = 8		self.write('Lets try a few more practice trials. \n Press Space when you are ready.', 'space')		self.sleep(1)		# Initialize matrix to gather data for first training block		trainData1 = np.zeros(shape = (nPractice1, 8))		# Loop through easy practice trials		self.cross = self.crosshair(duration=0.0, block=False, color = (0,0,0,1), size=self.fixationsize)		self.sleep(1)		for i in range(0, nPractice1):			 #trainData[i,:] = self.runtrialoffline(0, 0, int(round(np.random.rand())), trainlums)					# Old offline version			 trainData1[i,:] = self.runtrialonline(0, EEGinlet, 0, int(round(random.random())), trainlums1)			# New sham online version			 self.sleep(1)		# Turn off fixation cross after block of trials		self.cross.destroy()		self.sleep(1)		## Run some more practice trials, that are harder		nPractice2 = 12		self.write('Sometimes the flash might be difficult to see, or there might not be a flash. Press space when you are ready to try a few more trials.', 'space')		self.sleep(1)		# Initialize matrix to gather date for second training block		trainData2 = np.zeros(shape = (nPractice2, 8))		# Loop through difficult practice trials		self.cross = self.crosshair(duration=0.0, block=False, color = (0,0,0,1), size=self.fixationsize)		self.sleep(1)		for i in range(0, nPractice2):			 #trainData[i,:] = self.runtrialoffline(0, 0, int(round(np.random.rand())), trainlums)					# Old offline version			 trainData2[i,:] = self.runtrialonline(0, EEGinlet, 0, int(round(random.random())), trainlums2[random.randint(0,4)])			# New sham online version			 self.sleep(1)		# Turn off fixation cross after block of trials		self.cross.destroy()		self.sleep(1)		# Collect training data together		trainData = np.vstack([trainData1, trainData2])		## Break for the participant to self-initiate proceeeding with the experiment		self.write('If you have any questions about the task, please ask the experimenter now. If you are ready to continue, press space.', 'space')		## Return trial data		return trainData	def threshold_staircase(self):		""" This function runs the behavioural thresholding, using a staircase method. 		NOTE: CURRENTLY UNUSED		Inputs:			self 		- self object		Outputs:			threshData 	- A matrix of all the data from the thresholding trials			lums 		- The luminance values attained from the thresholding		"""		## Initialize luminances to return		lums = [0.8, 0.8]		nThreshTrials = self.nthreshtrials 		# Has to be an even number		lumDown = 0.01		lumUp = 0.005		# Create matrix for which side trial will be on		sideMatrix = np.append(np.zeros(nThreshTrials/2), np.ones(nThreshTrials/2))		random.shuffle(sideMatrix)		# Initialize matrix for data		threshData = np.zeros(shape = (nThreshTrials, 7))		# Set up arrays to check detection		leftdet = []		rightdet = []		leftlum = []		rightlum = []		# Print blank line to terminal to set apart threshold trials		print " "		# Print to screen to check if subject is ready to proceed		self.write("Press space when you are ready to start a block of trials", 'space')		## Loop through trials for thresholding		self.cross = self.crosshair(duration=0.0, block=False, color = (0,0,0,1), size=self.fixationsize)		for i in range(0, nThreshTrials):			# Run trial			threshTrial = self.runtrialoffline(1, i+1, int(sideMatrix[i]), lums)			# ThreshTrial = [trialtype, trialNum, displayed, side, lumUsed, saw, rt]			## Update Luminance			# Left side trial			if (threshTrial[3] == 0):				# Check if flash shown				if (threshTrial[2] == 1):					leftdet = np.append(leftdet, threshTrial[5])					leftlum = np.append(leftlum, threshTrial[4])					# Check if flash seen, if so decrease luminance					if (threshTrial[5] == 1):						lums[0] = lums[0] - lumDown					# If flash not seen, increase luminance					elif (threshTrial[5] == 0):						lums[0] = lums[0] + lumUp			# Right side trial			elif (threshTrial[3] == 1):				# Check if flash shown 				if (threshTrial[2] == 1): 					rightdet = np.append(rightdet, threshTrial[5])					rightlum = np.append(rightlum, threshTrial[4])					# Check if flash seen, if so decrease luminance					if (threshTrial[5] == 1):						lums[1] = lums[1] - lumDown					# If flash not seen, increase luminance					elif (threshTrial[5] == 0):						lums[1] = lums[1] + lumUp			threshData[i,:] = threshTrial			# Inter-trial Interval: Wait for random length			iti = 0.5 + random.random()			self.sleep(iti)			if (i == 49):				lumDown = 0.005				self.cross.destroy()				self.write('You may now take a short break. Press space when you are ready to continue.', 'space')				self.cross = self.crosshair(duration=0.0, block=False, color = (0,0,0,1), size=self.fixationsize)		# After 100 trials, check if detection is around 50%		nCheck = -20		leftdetmean = np.mean(leftdet[nCheck:])		rightdetmean = np.mean(rightdet[nCheck:])		leftlummean = np.mean(leftlum[nCheck:])		rightlummean = np.mean(rightlum[nCheck:])		lums = [leftlummean, rightlummean]		# Print out detection ratse		print ' '		print 'Left Detection Rate: ' + str(leftdetmean)		print 'Right Detection Rate: ' + str(rightdetmean)		print 'Left Lum Value: ' + str(leftlummean)		print 'Right Lum Value: ' + str(rightlummean)		print ' '		# Wrap things up		self.cross.destroy() # Crosshair off		self.write('You have finished this block of the experiment', 4)		# Return threshold data and luminance values		return threshData, lums	def threshold_quest(self, EEGinlet):		"""This function runs the behavioural thresholding, using the Quest Bayesian adaptive method.		Note: in the current design, possible luminance values are between 0.5 and 1.		Inputs:			self 		- self object			EEGinlet	- lsl stream to pull data from (to run sham-online trials during threshold)		Outputs:			threshData 	- A matrix of all the data from the thresholding trials			lums 		- The luminance values attained from the threshold		"""		## Initialize parameters for Quest		threshguess = .750 		# Prior (initial guess) for the threshold value		guessSD = 0.2 			# Standard Deviation of the prior		pThresh = 0.50			# Threshold criterion (50% detection)		beta = 3.5 				# Steepness of Weibull function. Typical value taken from Quest function		delta = 0.01			# Fraction of trials responded to blindly. Typical values taken from Quest function		gamma = 0.03			# Fraction of trials with response 1 when intensity = -inf.		grain = 0.01 			# The quantization of the interval table		threshrange = 0.5 		# Intensity difference range		# Initiate Quest Objects (one for each left & right)		qLeft = Quest.QuestObject(threshguess, guessSD, pThresh, beta, delta, gamma, grain, threshrange)		qRight = Quest.QuestObject(threshguess, guessSD, pThresh, beta, delta, gamma, grain, threshrange)		## Initialize things for trials		# Create matrix for which side trial will be on		nThreshTrials = self.nthreshtrials 		# Has to be an even number		lums = [0.900, 0.900]		sideMatrix = np.append(np.zeros(nThreshTrials/2), np.ones(nThreshTrials/2))		random.shuffle(sideMatrix)		# Initialize matrix for data		thresh_data = np.zeros(shape = (nThreshTrials, 8))		# Set up arrays to check detection		leftdet = []		rightdet = []		leftlum = []		rightlum = []		# Print blank line to terminal to set apart threshold trials		print " "		# Print to screen to check if subject is ready to proceed		self.write("Press space when you are ready to start a block of trials", 'space')		## Loop through trials for thresholding		self.cross = self.crosshair(duration=0.0, block=False, color = (0,0,0,1), size=self.fixationsize)		for i in range(0, nThreshTrials):			# Run trial - ThreshTrial = [trialtype, trialNum, displayed, side, lumUsed, saw, rt]			#thresh_trial = self.runtrialoffline(1, i+1, int(sideMatrix[i]), lums)			# Offline trial			thresh_trial = self.runtrialonline(1, EEGinlet, i, sideMatrix[i], lums)	# Sham online trial			thresh_trial[0] = 1			## Collect lum & detection information			# Left side trial			if (thresh_trial[3] == 0):				# Check if flash shown				if (thresh_trial[2] == 1):					leftlum = np.append(leftlum, thresh_trial[4])					leftdet = np.append(leftdet, thresh_trial[5])			# Right side trial			elif (thresh_trial[3] == 1):				# Check if flash shown 				if (thresh_trial[2] == 1): 					rightlum = np.append(rightlum, thresh_trial[4])					rightdet = np.append(rightdet, thresh_trial[5])			# Collect all data together in matrix			thresh_data[i,:] = thresh_trial			## Update quest pdfs & luminance values (only if trial was presented)			# Here, using QuestQuantile & QuestMean - see Quest.py for details			# Left side trial			if ((thresh_trial[3] == 0) & (thresh_trial[2] == 1)):				qLeft.update(thresh_trial[4], thresh_trial[5])				lums[0] = qLeft.quantile()				if lums[0] < 0.5:					lums[0] = 0.5				#print 'HERE: ' + str(lums[0])			# Right side trial			if ((thresh_trial[3] == 1) & (thresh_trial[2] == 1)):				qRight.update(thresh_trial[4], thresh_trial[5])				lums[1] = qRight.quantile()				if lums[1] < 0.5:					lums[1] = 0.5				#print 'HERE: ' + str(lums[1])			# Inter-trial Interval: Wait for random length			iti = 0.5 + random.random()			self.sleep(iti)			if ((i+1)% 48 == 0):				self.cross.destroy()				self.write('You may now take a short break. Press space when you are ready to continue.', 'space')				self.cross = self.crosshair(duration=0.0, block=False, color = (0,0,0,1), size=self.fixationsize)		# After 100 trials, check if detection is around 50%		nCheck = -20		leftdetmean = np.mean(leftdet[nCheck:])		rightdetmean = np.mean(rightdet[nCheck:])		leftlummean = np.mean(leftlum[nCheck:])		rightlummean = np.mean(rightlum[nCheck:])		#lums = [leftlummean, rightlummean]		# Print out detection ratse		print 'Left Detection Rate: ' + str(leftdetmean)		print 'Right Detection Rate: ' + str(rightdetmean)		print 'Left Lum Value: ' + str(leftlummean)		print 'Right Lum Value: ' + str(rightlummean)		print ' '		# Get final estimate		thresh_estimate_left = qLeft.mean()		thresh_estimate_right = qRight.mean()		estimate_sd_left = qLeft.sd()		estimate_sd_right = qRight.sd()		print '\nMean threshold estimate for left is %4.2f +/- %.2f'%(thresh_estimate_left,estimate_sd_left)		print 'Mean threshold estimate for right is %4.2f +/- %.2f'%(thresh_estimate_right,estimate_sd_right)    			# Wrap things up		self.cross.destroy() # Crosshair off		self.write('You have finished this block of the experiment', 4)		# Set luminances at Quest estimate thresholds to return		lums = [thresh_estimate_left, thresh_estimate_right]		## Save pickled Quest objects		obj_savepath = '.\\modules\\CBCI\\Data\\'		# Left quest object		file_left_name = obj_savepath + str(self.subnum) + '_' + self.datetimenow + 'questleft.obj'		file_left = open(file_left_name, 'w')		pickle.dump(qLeft, file_left)		file_left.close()		# Right quest object		file_right_name = obj_savepath + str(self.subnum) + '_' + self.datetimenow + 'questright.obj'		file_right = open(file_right_name, 'w')		pickle.dump(qRight, file_right)		file_right.close()		# Return threshold data and luminance values		return thresh_data, lums	def runlabelblock(self, EEGinlet, trialtype):		""" This function runs the online labelling, without any task involved.		It can be used for labelling data with resting data, eyes open or closed		Inputs:			self 		- self object			EEGinlet	- lsl stream to pull EEG from			trialtype	- the type of online prediction to use (filt or thresh)		Outputs:			None		"""		# Set up variables		nblocks = 1		ntrialblock = self.ntrialperblock		# Get ready to present block		self.write('In this block, you just need to sit still with your eyes closed.', 'space')		self.write('Press space when you are ready to begin.', 'space')		self.sleep(5)			# Check type of block ('filt' or 'thresh')		if (trialtype == 'filt'):			print "Running Filter Labelling Block"			self.marker('Filt Labelling')		elif (trialtype == 'thresh'):			print "Running Threshold Labelling Block"			self.marker('Thresh Labelling Block')		# Run a block of EEG labelling		for block in range(0, nblocks):			# Send start of block label			self.marker('Start Labelling Block')			# Loop through trials			for trial in range(0, ntrialblock):				self.runlabeltrial(trialtype, EEGinlet)				iti = 0.5 + random.random()				self.sleep(iti)			# Send marker for end of block			self.marker('End Labelling Block')			print "\n End Labelling Block \n"			# Self-paced break for participants between blocks			#self.write('You may now take a break. \n Press space when you are ready to continue.', 'space', block=True)			self.write('You have finished this block of the experiment', 5)	def runofflineblock(self, EEGinlet, lums):		""" This function runs a block of detection trials offline.		NOTE: CURRENTLY UNUSED. Is set to run sham online trial.		Inputs:			self 		- self object			lums 		- thresholded luminances to use		Outputs:			offlinedata 	- a matrix with all the data from the online part of the experiment								[trialNum, displayed, side, luminance, saw, rt]		"""		# Set up variables		nblocks = 2		ntrialblock = self.ntrialperblock	# Needs to be an even number		# Get ready to present block		self.write('Press when you are ready for a block of trials', 'space')		self.sleep(2)		# Loop through blocks		for block in range(0, nblocks):			# Set up matrix for block data			blockdata = np.zeros(shape = (ntrialblock, 8))			# Set up side matrix for which side to present trial on			sideMatrix = np.append(np.zeros(ntrialblock/2), np.ones(ntrialblock/2))			random.shuffle(sideMatrix)			# Send marker for start of block			self.marker('Start Offline Block')			# Set up fixation cross			self.cross = self.crosshair(duration=0.0, block=False, color = (0,0,0,1), size=self.fixationsize)			self.sleep(2)			# Loop through trials			for trial in range(0, ntrialblock):				#offlinetrialdata = self.runtrialoffline(2, trial+1, sideMatrix[trial], lums)		# Old real offline				offlinetrialdata = self.runtrialonline(2, EEGinlet, trial+1, sideMatrix[trial], lums)				blockdata[trial, :] = offlinetrialdata				iti = 0.5 + random.random()				self.sleep(iti)			# Send marker for end of block			self.marker('End Offline Block')			# Collect all data together			if (block == 0):				offlinedata = blockdata			else:				offlinedata = np.vstack([offlinedata, blockdata])			# Turn off cross-hair after block			self.cross.destroy()			# Self-paced break for participants between blocks			self.write('You may now take a break. \n Press space when you are ready to continue.', 'space', block=True)		# Return block data		return offlinedata	def runonlineblock(self, EEGinlet, trialtype, lums):		""" This function runs the main part of the experiment (the online part).		NOTE: CURRENTLY UNUSED		Inputs:			self 		- self object			EEGinlet 	- lsl stream to pull EEG from			trialtype	- the real-time method to use ('filt' or 'thresh')			lums 		- thresholded luminances to use		Outputs:			allexperimentdata 	- a matrix with all the data from the online part of the experiment		"""		# Set up variables		nblocks = 1		ntrialblock = self.ntrialperblock		# Check type of block ('filt' or 'thresh')		if (trialtype == 'filt'):			print "Running Filter Online Block"			self.marker('Filt Online')			runtype = 3		elif (trialtype == 'thresh'):			print "Running Threshold Online Block"			self.marker('Thresh Online')			runtype = 4		# Get ready to present block		self.write('Press space when you are ready for a block of trials', 'space')		self.sleep(2)		# Loop through blocks		for block in range(0, nblocks):			# Set up matrix for block data			blockdata = np.zeros(shape = (ntrialblock, 8))			# Set up side matrix for which side to present trial on			sideMatrix = np.append(np.zeros(ntrialblock/2), np.ones(ntrialblock/2))			random.shuffle(sideMatrix)			# Send marker for beginning of block			self.marker('Start Online Block')			# Set up fixation cross			self.cross = self.crosshair(duration=0.0, block=False, color = (0,0,0,1), size=self.fixationsize)			self.sleep(2)			# Loop through trials			for trial in range(0, ntrialblock):				rttrialdata = self.runtrialonline(runtype, EEGinlet, trial+1, sideMatrix[trial], lums)				blockdata[trial, :] = rttrialdata				iti = 0.5 + random.random()				self.sleep(iti)			# Send marker for end of block			self.marker('End Online Block')			# Collect all data together			if block == 0:				onlinedata = blockdata			else:				onlinedata = np.vstack([onlinedata, blockdata])			# Turn off cross-hair after block			self.cross.destroy()			# Self-paced break for participants between blocks			self.write('You may now take a break. \n Press space when you are ready to continue.', 'space', block=True)		# Return block data		return onlinedata	def runblock(self, EEGinlet, lums):		""" This function runs the main part of the experiment (the online part).		Inputs:			self 		- self object			EEGinlet 	- lsl stream to pull EEG from			trialtype	- the real-time method to use ('filt' or 'thresh')			lums 		- thresholded luminances to use		Outputs:			allexperimentdata 	- a matrix with all the data from the online part of the experiment		"""		# Set up variables		ntrialblock = self.ntrialperblock		print "\nRunning Block Number: " + str(self.blocknumber) + "\n"		# Get ready to present block		self.write('Press space when you are ready for a block of trials.', 'space')		self.sleep(2)		# Set up matrix for block data		blockdata = np.zeros(shape = (ntrialblock, 8))		# Set up side matrix for which side to present trial on		sideMatrix = np.append(np.zeros(ntrialblock/2), np.ones(ntrialblock/2))		random.shuffle(sideMatrix)		# Set up runtype matrix for what type of trial to present		runMatrix = np.append((np.ones(ntrialblock/3) * 2), (np.ones(ntrialblock/3) * 3)) 		runMatrix = np.append(runMatrix, (np.ones(ntrialblock/3) * 4))		random.shuffle(runMatrix)		# Send marker for beginning of block		self.marker('Start Block')		# Set up fixation cross		self.cross = self.crosshair(duration=0.0, block=False, color = (0,0,0,1), size=self.fixationsize)		self.sleep(2)		# Loop through trials		for trial in range(0, ntrialblock):			rttrialdata = self.runtrialonline(runMatrix[trial], EEGinlet, trial+1, sideMatrix[trial], lums)			blockdata[trial, :] = rttrialdata			iti = 0.5 + random.random()			self.sleep(iti)		# Send marker for end of block		self.marker('End Block')		# Turn off cross-hair after block		self.cross.destroy()		# Print to shell block number		print "\n End of Block Number: " + str(self.blocknumber) + "\n"		# Self-paced break for participants between blocks		self.write('You have finished this block of trials', 5)		#self.write('You may now take a break. \n Press space when you are ready to continue.', 'space', block=True)		# Update block number		self.blocknumber = self.blocknumber + 1		# Return block data		return blockdata	def runlabeltrial(self, trialtype, EEGinlet):		""" This function labels peaks & troughs without invoking the task.		Can be run on subject with their eyes closed.		Inputs:			self 		- self object			EEGinlet	- lsl stream to pull EEG from		Outputs:			None		"""		# Start		print "Running detection trial"		# Pull EEG data and predict using the filter method		if (trialtype == 'filt'):			detType, prestime = self.sampletrialdatafilt(EEGinlet)		elif (trialtype == 'thresh'):			detType, prestime = self.sampletrialdatathresh(EEGinlet)				## Write a label at the time of the peak or trough prediction		# Get current time		now = tm.time()*1000 # in ms		# Loop through, waiting for the time to present		# Peak Label		if (detType == 0):			while True:				if now < prestime:					now = tm.time()*1000 	#in ms					pass				else:					self.marker('Label_Peak_'+trialtype)					print 'Peak label'					break		# Trough Label		elif (detType == 1):			while True:				if now < prestime:					now = tm.time()*1000 	#in ms					pass				else:					self.marker('Label_Trough_'+trialtype)					print 'Trough label'					break	def runtrialoffline(self, trialtype, trialNum, side, lums):		""" This function runs a single trial offline (not using EEG to set flash time)		NOTE: CURRENTLY UNUSED		Inputs:			self 		- self object			trialtype	- [0: train, 1:thresh, 2:offline, 3: filt-online, 4: thresh-online]			trialNum 	- which trial it is			side 		- Side to displayon [0:Left, 1:Right]			lums 		- Luminance values [leftLum, rightLum]		Outputs:			trialData 	- vector of data from the trial						[trialType, trialNum, displayed, side, lumUsed, saw, rt]		"""		## Determine whether to flash		trialrand = random.random()		# Always show flash on training runs		if trialtype == 0:			disp = 1			if (side == 0):				luminance = lums[0]			else:				luminance = lums[1]			#self.marker('Trial_'+str(trialNum)+'_Display_'+str(disp))		# If not a training trial, use a random generator to not flash on 20% of trials		else:			if trialrand < 0.2:					luminance = 0.5				disp = 0				#self.marker('Trial_'+str(trialNum)+'_Display_'+str(disp)) 					else:				disp = 1				if (side == 0):					luminance = lums[0]				else:					luminance = lums[1]				#self.marker('Trial_'+str(trialNum)+'_Display_'+str(disp))		## Start trial		self.now = int(round(tm.time() * 1000))		# Time to the closest millisecond		self.marker('Trial_'+str(disp))		# Set up left side trial		if (side == 0):				self.lefttop = self.rectangle(duration=0.0, block=False, color = (0,0,0,1), rect=self.lefttoppos) #Psychtoolbox			self.leftbottom = self.rectangle(duration=0.0, block=False, color = (0,0,0,1), rect=self.leftbotpos) #Psychtoolbox			self.marker('Markers_'+str(side))			self.sleep(1+random.random())			self.leftmiddle = self.rectangle(duration=self.flashtime, block=True, color = (luminance, luminance, luminance, 1), rect=self.leftmidpos) #Psychtoolbox			self.marker('Flash_'+str(disp))			self.pretime = int(round(tm.time() * 1000))			#self.marker('Trial_'+str(trialNum)+'_Start_Stim_'+str(self.pretime))		# Right side trial		elif (side == 1):			self.righttop = self.rectangle(duration=0.0, block=False, color = (0,0,0,1), rect=self.righttoppos)			self.rightbottom = self.rectangle(duration=0.0, block=False, color = (0,0,0,1), rect=self.rightbotpos)			self.marker('Markers'+str(side))			self.sleep(1+random.random())			self.rightmiddle = self.rectangle(duration=self.flashtime, block=True, color = (luminance, luminance, luminance, 1), rect=self.rightmidpos)			self.marker('Flash_'+str(disp))			self.pretime = int(round(tm.time() * 1000))			#self.marker('Trial_'+str(trialNum)+'_Start_Stim_'+str(self.pretime))		# Get time and mark end of stim		self.now = int(round(tm.time() * 1000))		#self.marker('Trial_'+str(trialNum)+'_End_Stim_'+str(self.now))		timeleft = (1500.0 - (self.now - self.pretime))/1000.0		## Watch for response - updated		resp = self.waitfor('space', timeleft)		if (resp == None):			saw = 0			rt = None			self.marker('UnseenTrial')			#self.marker('Trial_'+str(trialNum)+'No Resp')		else:	# NOTE: check if resp is the real reaction time			saw = 1			rt = resp			self.marker('SeenTrial')			#self.marker('Trial_'+str(trialNum)+'Saw_'+str(rt))		# Clear all rectangles on screen		if (side == 0):			self.lefttop.destroy()			self.leftbottom.destroy()		elif (side == 1):			self.righttop.destroy()			self.rightbottom.destroy()		# Send marker that trial is cleared		#self.marker('Trial_'+str(trialNum)+'_End_Cues_'+str(saw))		## Output data		# Collect data together		trialdata = [trialtype, trialNum, disp, side, luminance, saw, rt]		# Print data to file		print "Type: " + str(trialtype) + " Trial #: " + str(trialNum) + " Disp: " + str(disp) + " Side" + str(side) + " Lum: " + str(luminance) + " Saw: " + str(saw) + " RT: " + str(rt)		strlist = [str(trialtype), str(trialNum), str(disp), str(side), str(luminance), str(saw), str(rt)]		strlist = ",".join(strlist)		self.dataf = open(self.datafn, 'a')		self.dataf.write(strlist+'\n')		self.dataf.close()		# Return trial data		return trialdata	def runtrialonline(self, runtype, EEGinlet, trialNum, side, lums):		""" This function runs the trials that use EEG to pick presentation time.		Inputs:			self 		- self object			runtype 	- which trial type to run(0:train, 1: threshold, 2:sham online, 3:filt, 4:thresh)			EEGinlet	- lsl inlet to stream EEG data			trialNum 	- which trial it is			side 		- 0:Left, 1:Right			lums 		- 	[leftLum, rightLum]			Outputs:			trialData 	- vector of data from the trial							[runtype, trialNum, displayed, side, lumUsed, saw, rt, detType]		"""		## Determine whether to flash		# NOTE: CURRENTLY SET TO DISPLAY ON ALL TRIALS		print "Running Online Trial. RunType: ", runtype		#trialrand = random.random()		disp = 1		if (int(side) == 0):			luminance = lums[0]		else:			luminance = lums[1]				## Start trial		self.now = int(round(tm.time() * 1000))		# Time to the closest millisecond		#self.marker('Trial_rt_' + str(trialNum) + '_Side_' + str(side) + '_Lum_' + str(luminance) + '_Start_'+str(self.now))		if (int(side) == 0):		# Left side trial - set up rectangles			self.lefttop = self.rectangle(duration=0.0, block=False, color = (0,0,0,1), rect=self.lefttoppos) #Psychtoolbox			self.leftbottom = self.rectangle(duration=0.0, block=False, color = (0,0,0,1), rect=self.leftbotpos) #Psychtoolbox			self.marker('Markers'+str(side))			self.sleep(0.1)		elif (int(side) == 1):		# Right side trial - set up rectangles			self.righttop = self.rectangle(duration=0.0, block=False, color = (0,0,0,1), rect=self.righttoppos)			self.rightbottom = self.rectangle(duration=0.0, block=False, color = (0,0,0,1), rect=self.rightbotpos)			self.marker('Markers'+str(side))			self.sleep(0.1)		## Pull EEG data using specified method		# Training trials		if (runtype == 0):			trialtype = 'train'			# Randomly pull from either thresh or filt method			if (int(round(random.random())) == 0):				detType, prestime = self.sampletrialdatafilt(EEGinlet)			else:				detType, prestime = self.sampletrialdatathresh(EEGinlet)		# Behavioural threshold trials		elif (runtype == 1):			trialtype = 'threshold'			# Randomly pull from either thresh or filt method			if (int(round(random.random())) == 0):				detType, prestime = self.sampletrialdatafilt(EEGinlet)			else:				detType, prestime = self.sampletrialdatathresh(EEGinlet)		# Sham online trials		elif (runtype == 2):			trialtype = 'sham'			# Randomly pull from either thresh or filt method			if (int(round(random.random())) == 0):				detType, prestime = self.sampletrialdatafilt(EEGinlet)			else:				detType, prestime = self.sampletrialdatathresh(EEGinlet)		# Filt method trials		elif (runtype == 3):			self.sleep(random.random()/10)			trialtype = 'filt'			detType, prestime = self.sampletrialdatafilt(EEGinlet)		# Thresh method trials		elif (runtype == 4):			trialtype = 'thresh'			detType, prestime = self.sampletrialdatathresh(EEGinlet)		# If a train / threshold or sham trial - randomize		if (trialtype == 'train' or trialtype == 'threshold' or trialtype == 'sham'):			detType = int(round(random.random()))			#prestime = 100.0 		# Note - update this to better random prediction			prestime = (tm.time() * 1000) + (random.random() * 100)		## Try to flash at time of peak or trough prediction		# Get current time		now = tm.time()*1000 # in ms		#print "Now: " + str(now)		#print "Prestime: " + str(prestime)		# Peak trial		if (detType == 0):			#print "Peak"			if (side == 0):		# Left side				while True:					if now < prestime:						now = tm.time()*1000 	#in ms						pass					else:						self.leftmiddle = self.rectangle(duration=self.flashtime, block=True, color = (luminance, luminance, luminance, 1), rect=self.leftmidpos) #Psychtoolbox						self.marker('Peak_Pres_' + str(trialtype))						self.pretime = int(round(tm.time() * 1000))						#self.marker('Trial_rt_peak_'+str(trialNum)+'_Start_Stim_'+str(self.pretime))						print 'Peak Presentation'						break			elif (side == 1):	# Right Side				while True:					if now < prestime:						now = tm.time()*1000 	#in ms						pass					else:						self.rightmiddle = self.rectangle(duration=self.flashtime, block=True, color = (luminance, luminance, luminance, 1), rect=self.rightmidpos)						self.marker('Peak_Pres_' + str(trialtype))						self.pretime = int(round(tm.time() * 1000))						#self.marker('Trial_rt_peak_'+str(trialNum)+'_Start_Stim_'+str(self.pretime))						print 'Peak Presentation'						break		# Trough trial		elif (detType == 1):	# Trough trial			#print "Trough"			if (side == 0):		# Left side				while True:					if (now < prestime):						now = tm.time()*1000 	#in ms						pass					else:						self.leftmiddle = self.rectangle(duration=self.flashtime, block=True, color = (luminance, luminance, luminance, 1), rect=self.leftmidpos)						self.marker('Trough_Pres_' + str(trialtype))						self.pretime = int(round(tm.time() * 1000))						#self.marker('Trial_rt_trough_'+str(trialNum)+'_Start_Stim_'+str(self.pretime))						print 'Trough Presentation'						break			elif (side == 1):	# Right side				while True:					if now < prestime:						now = tm.time()*1000 	#in ms						pass					else:						self.rightmiddle = self.rectangle(duration=self.flashtime, block=True, color = (luminance, luminance, luminance, 1), rect=self.rightmidpos)						self.marker('Trough_Pres_' + str(trialtype))						self.pretime = int(round(tm.time() * 1000))						#self.marker('Trial_rt_trough_'+str(trialNum)+'_Start_Stim_'+str(self.pretime))						print 'Trough Presentation'						break		# Undetected trial - present randomly		elif (detType == 2):			if (side == 0):		# Left side				self.leftmiddle = self.rectangle(duration=self.flashtime, block=True, color = (luminance, luminance, luminance,1), rect=self.leftmidpos)				self.pretime = int(round(tm.time() * 1000))				#self.marker('Trial_rt_und_'+str(trialNum)+'_Start_Stim_'+str(self.pretime))				print 'Undetected Left Presentation'			elif (side == 1):	# Right side				self.rightmiddle = self.rectangle(duration=self.flashtime, block=True, color = (luminance, luminance, luminance, 1), rect=self.rightmidpos)				self.pretime = int(round(tm.time() * 1000))				#self.marker('Trial_rt_und_'+str(trialNum)+'_Start_Stim_'+str(self.pretime))				print 'Undetected Right Presentation'		# Get time and mark end of stim		self.now = int(round(tm.time() * 1000))		# time, in ms		#self.marker('Trial_rt_'+str(trialNum)+'_End_Stim_'+str(self.now))		timeleft = (2000.0 - (self.now - self.pretime))/1000.0		## Watch for response		resp = self.waitfor('space', timeleft)		if (resp == None):			saw = 0			rt = None			self.marker('MissTrial')			#self.marker('Trial_rt_'+str(trialNum)+'No Resp')		else:	# NOTE: check if resp is the real reaction time			saw = 1			rt = resp			self.marker('HitTrial')			#self.marker('Trial_rt_'+str(trialNum)+'Saw_'+str(rt))		# Clear all rectangles on screen		if (side == 0):			self.lefttop.destroy()			self.leftbottom.destroy()		elif (side == 1):			self.righttop.destroy()			self.rightbottom.destroy()		## Output data		# Collect data together		rttrialdata = [runtype, trialNum, disp, side, luminance, saw, rt, detType]		# Print data to shell		print "Type: " + str(runtype) + " Trial #: " + str(trialNum) + " Disp: " + str(disp) + " Side" + str(side) + " Lum: " + str(luminance) + " Saw: " + str(saw) + " RT: " + str(rt) + " Det: " + str(detType)				#print "Type: {0}  Trial #: {1}  Disp: {2}  Side: {3}  Lum: {4:.3f}  Saw: {5}  RT: {6:.4f}  Det: {7}".format(runtype, trialNum, disp, side, luminance, saw, rt, detType)		# Print data to file		strlist = [str(runtype), str(trialNum), str(disp), str(side), str(luminance), str(saw), str(rt), str(detType)]		strlist = ",".join(strlist)		self.dataf = open(self.datafn, 'a')		self.dataf.write(strlist+'\n')		self.dataf.close()		# Return trial data		return rttrialdata	def sampletrialdatafilt(self, EEGinlet):		""" Collects EEG data from the lsl stream for an online presentation trial. It then		uses the filtering method, running the peak detection, predicts a peak or trough which it returns. 		Inputs:			self 		- Self			EEGinlet	- Data stream from LSL (EEG data stream)		Outputs:		 	detType		- Label for peak [0], trough [1] or undetected [2]		 	prestime	- The predicted time of the upcoming peak or trough in ms (None if undetected)		"""		# Initialize parameters		EEGsample = pylsl.vectorf()		nsamples = self.nsamples 		# Number of samples to collect		EEGwindow = np.zeros(nsamples)		time = np.arange(nsamples)*(1.0/self.srate)		## Clear buffer		while EEGinlet.pull_sample(EEGsample,0.0): # Clear buffer			pass		## Sample data		for sampleIndex in np.arange(0,nsamples):			EEGinlet.pull_sample(EEGsample)			# Re-reference and take single channel			EEGwindow[sampleIndex] = EEGsample[self.chans[0]]-EEGsample[self.chans[1]]			# Non-rereferenced data			#EEGwindow[sampleIndex] = EEGsample[self.chans[0]]		timecollected = tm.time()*1000		#Time after collection, in ms, before processing		# Process data stream		EEGwindow = EEGwindow-np.mean(EEGwindow)		filtered_data = np.convolve(EEGwindow,self.bp,'same')					## Take PSD		#f,psd = sp.signal.welch(filtered_data, fs=self.srate, window='hanning', nperseg=1024., nfft=2048, detrend='linear', return_onesided=True, scaling='density')		# Check power in alpha		#alpha = psd[self.alpha]		#rest = np.delete(psd, 3)		#restmean = np.mean(rest)		# Print restmean, to check values		#print "Restmean: ", restmean		# Skip section if alpha power is too low		#if alpha/restmean < 150.:		# Rob uses 250		#	print 'Skipped power'		#	detType = 2		#	return detType, None		# Run peak detection		maxtab, mintab = self.peakdet(filtered_data, 1)		## Plots		#print len(self.EEGsectimes), len(filtered_data)		#plt.plot(self.EEGsectimes, EEGwindow,'b')		#plt.plot(self.EEGsectimes, filtered_data,'g')		#plt.plot(self.EEGsectimes[maxtab], filtered_data[maxtab],'ro')		#plt.plot(self.EEGsectimes[mintab], filtered_data[mintab],'bo')		#plt.show()		## Predict next peak via median		# self.peakdiffs.extend(np.diff(maxtab)) # Update diffs		peakwidth = np.median(np.diff(maxtab)) # Find median diff from updated		lastpeak = maxtab[-1]		nextpeaksamp = 1*peakwidth - (self.nsamples - lastpeak) # how far away is the next peak, in sample		nextpeaktime = ((nextpeaksamp/self.srate) * 1000) + timecollected # what is the time of next peak, in milliseconds		## Predict next trough via median		#self.troughdiffs.extend(np.diff(mintab)) # Update diffs		troughwidth = np.median(np.diff(mintab)) # Find median diff from updated		lasttrough = mintab[-1]		nexttroughsamp = 1*troughwidth - (self.nsamples - lasttrough) # how far away is the next trough, in samples		nexttroughtime = ((nexttroughsamp/self.srate) * 1000) + timecollected # what is the time of the next peak, in milliseconds		# Mark time 		now = tm.time()*1000		# If predicted time is upcoming, return time to be used for presentation		if nextpeaktime > nexttroughtime:			detType = 0			return detType, nextpeaktime		elif nexttroughtime > nextpeaktime:			detType = 1			return detType, nexttroughtime		# Skip if predicted time already passed and return		elif now >= nextpeaktime and now >= nexttroughtime:			print 'Skipped too late'			detType = 2			return detType, None		else:			print 'Not returned'			detType = 2			return detType, None	def peakdet(self, input_vector, delta):		""" This function takes a vector of EEG data and labels peaks & troughs. 		Inputs:			input_vector	- vector of EEG data to label			delta 			- ?		Outputs			maxtab			- vector of peak indeces			mintab			- vector of trough indeces		"""		## NOTE: TO DO - CLEARN UP THIS FUNCTION!		## Set up variables		maxtab = []		mintab = []		domain = arange(len(input_vector))		input_vector = asarray(input_vector)		# Initialize voltage values of min and max		nearest_min, nearest_max = Inf, -Inf		# Initialize position (indeces) of min and max voltage		nearest_min_pos, nearest_max_pos = NaN, NaN		lookformax = True		# Loops through looking for the max and min values		for sample_index in domain:			sample = input_vector[sample_index]			if sample > nearest_max:				nearest_max = sample				nearest_max_pos = domain[sample_index]			if sample < nearest_min:				nearest_min = sample				nearest_min_pos = domain[sample_index]			# If current max passes a certain threshold, add to max vector, and start looking for trough			if lookformax:					if sample < nearest_max-delta: # if passes vertical threshold						# if not maxtab:						maxtab.append(nearest_max_pos)						nearest_min = sample						nearest_min_pos = domain[sample_index]						lookformax = False						# else:							# if (sample_index - maxtab[-1] > 136):								# maxtab.append(nearest_max_pos)								# nearest_min = sample								# nearest_min_pos = domain[sample_index]								# lookformax = False			else:				if sample > nearest_min+delta:					# if not mintab:					mintab.append(nearest_min_pos)					nearest_max = sample					nearest_max_pos = domain[sample_index]					lookformax = True					# else:						# if (sample_index - mintab[-1] > 136):							# mintab.append(nearest_min_pos)							# nearest_max = sample							# nearest_max_pos = domain[sample_index]							# lookformax = True		return maxtab, mintab	def sampletrialdatathresh(self, EEGinlet):		""" Collects EEG data from the lsl stream for an online presentation trial. It uses		the threshold method to predict a peak or trough, and returns it. 		Inputs:			self 		- Self			EEGinlet	- Data stream from LSL (EEG data stream)		Outputs:		 	detType		- Label for peak [0], trough [1] or undetected [2]		 	prestime	- The predicted time of the upcoming peak or trough in ms (None if undetected)		"""		# Initialize parameters		EEGsample = pylsl.vectorf()		EEGsamp = pylsl.vectorf()		nsamples = self.srate		# Number of samples to collect		EEGwindow = np.zeros(nsamples)		time = np.arange(nsamples)*(1.0/self.srate)		# From a peak/trough, how far away is the next one		predicttime = 1000./self.alpha 	# in ms		## Clear buffer		while EEGinlet.pull_sample(EEGsample,0.0): # Clear buffer			pass		## Sample a section of data to run threshold on		for sampleIndex in np.arange(0,nsamples):			EEGinlet.pull_sample(EEGsample)			# Re-reference and take single channel			EEGwindow[sampleIndex] = EEGsample[self.chans[0]]-EEGsample[self.chans[1]]			# Non-rereferenced data			#EEGwindow[sampleIndex] = EEGsample[self.chans[0]]		#timecollected = tm.time()		#Time after colletion, before processing		## Plot the EEG data in the window		#plt.figure(1)		#plt.plot(EEGwindow)		#plt.show()		# Process data stream - demean		mean = np.mean(EEGwindow)		EEGwindow = EEGwindow-mean		# Take percentiles		[bottompercentile, toppercentile] = np.percentile(EEGwindow, [0.5, 99.5])		## Clear buffer		while EEGinlet.pull_sample(EEGsample,0.0): # Clear buffer			pass		## Loop through looking for a peak or trough, as defined by a sample above or		# below the thresholds defined. Returns detType and prestime when found.		# Loops through for half a second here		for i in range(0, int(nsamples)):			EEGinlet.pull_sample(EEGsamp)			checksample = (EEGsamp[self.chans[0]] - EEGsamp[self.chans[1]]) - mean			#checksample = (EEGsamp[self.chans[0]]) - mean			#print "Sample", checksample			if (checksample > toppercentile):				detType = 0				#prestime = timestamp*1000 + predicttime				prestime = (tm.time()*1000) + predicttime				return detType, prestime			elif (checksample < bottompercentile):				detType = 1				#prestime = timestamp*1000 + predicttime				prestime = (tm.time()*1000) + predicttime				return detType, prestime		# If after half a second, nothing has returned, return an undetected trial		detType = 2		prestime = None		print "Thresh Timed Out"		return detType, prestime	def checkstream(self, EEGinlet):		""" Runs the checks on the current stream.		Inputs:			self 		- Self			EEGinlet	- Data stream from LSL (EEG data stream)		Outputs:			None		"""		# Get Stream Info		streaminfo = EEGinlet.info()		print ' '		# Check for time correction		self.streamtimecorrection = EEGinlet.time_correction()		print "Time correction is: ", self.streamtimecorrection		# Test EEG input		testsample = pylsl.vectorf()		timestamp = EEGinlet.pull_sample(testsample)		print "EEG: ", timestamp, testsample[1]		print timestamp+EEGinlet.time_correction(), tm.time()		#print np.shape(testsample)		# Check content type		self.streamtype = streaminfo.type()		print "Stream Type", self.streamtype		# Check stream name		self.streamname = streaminfo.name()		print "Stream Name", self.streamname		# Check sampling rate		self.streamsrate = streaminfo.nominal_srate()		print "Sampling Rate", self.streamsrate		# Check number of channels		self.streamnchans = streaminfo.channel_count()		print "Number of Channels", self.streamnchans		# Check channel format		#chanformat = streaminfo.channel_format()		#print "Channel Format", chanformat		print ' '	def experimentlog(self):		""" Writes a log with relevant run information. 		Inputs:			self 		- Self		Outputs:		 	None		"""		## Set up & open file for experiment log		logfilename = '.\\modules\\CBCI\\ExpLog\\' + str(self.subnum) + '_' + self.datetimenow + '_RunLog.txt'		logfile = open(logfilename,'w')				## Write to file		# Basic Information		logfile.write('\n RUN INFORMATION \n')		logfile.write('Run Version: ' + str(self.runversion) + '\n')		logfile.write('Subject Number: ' + str(self.subnum) + '\n')		logfile.write('Condition: ' + str(self.condition) + '\n')		logfile.write('Date: ' + str(self.datetimenow) + '\n')		# Software Information		logfile.write('\n SOFTWARE INFORMATION \n')		logfile.write('Pylsl Protocol Version: ' + str(self.lslprotocolversion) + '\n')		logfile.write('Pylsl Library Version: ' + str(self.lsllibraryversion) + '\n')		# EEG Information		logfile.write('\n EEG INFORMATION \n')		logfile.write('EEG System: ' + str(self.eegsystem) + '\n')		logfile.write('Channels Used Online: ' + str(self.chans) + '\n')		logfile.write('Set Sampling Rate: ' + str(self.srate) + '\n')		logfile.write('Number Samples Used Online: ' + str(self.nsamples) + '\n')		# Stream Information		logfile.write('\n STREAM INFORMATION \n')		logfile.write('Stream Name: ' + str(self.streamname) + '\n')		logfile.write('Stream Type: ' + str(self.streamtype) + '\n')		logfile.write('Stream Sampling Rate: ' + str(self.streamsrate) + '\n')		logfile.write('Stream Number of Channels: ' + str(self.streamnchans) + '\n')		logfile.write('Time Correction: ' + str(self.streamtimecorrection) + '\n')		# Presentation Information		logfile.write('\n PRESENTATION INFORMATION \n')		logfile.write('Flash Time: ' + str(self.flashtime) + '\n')		logfile.write('Fixation Size: ' + str(self.fixationsize) + '\n')		logfile.write('Left Top Position: ' + str(self.lefttoppos) + '\n')		logfile.write('Left Bottom Position: ' + str(self.leftbotpos) + '\n')		logfile.write('Right Top Position: ' + str(self.righttoppos) + '\n')		logfile.write('Right Bottom Position: ' + str(self.rightbotpos) + '\n')		logfile.write('Left Middle Position: ' + str(self.leftmidpos) + '\n')		logfile.write('Right Middle Position: ' + str(self.rightmidpos) + '\n')		# Close log file		logfile.close()